#!/usr/bin/env python3

import logging
from typing import Dict, List, Optional
import socket
import ssl
from dataclasses import dataclass
from scapy.all import IP, TCP, UDP, sr1
import requests
from concurrent.futures import ThreadPoolExecutor

@dataclass
class Vulnerability:
    name: str
    description: str
    severity: str
    port: int
    service: str
    recommendations: List[str]

class VulnerabilityScanner:
    """Advanced Vulnerability Scanner"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.executor = ThreadPoolExecutor(max_workers=10)
        self._initialize_vulnerability_checks()
        
    def _initialize_vulnerability_checks(self):
        """Initialize known vulnerability checks"""
        self.vulnerability_checks = {
            'ssh': self._check_ssh_vulnerabilities,
            'ftp': self._check_ftp_vulnerabilities,
            'http': self._check_http_vulnerabilities,
            'https': self._check_https_vulnerabilities,
            'smtp': self._check_smtp_vulnerabilities,
            'mysql': self._check_mysql_vulnerabilities,
            'postgresql': self._check_postgresql_vulnerabilities
        }
        
    def scan_target(self, target: str, open_ports: List[Dict]) -> List[Vulnerability]:
        """Scan target for vulnerabilities"""
        vulnerabilities = []
        
        for port_info in open_ports:
            port = port_info['port']
            service = port_info['service'].lower() if port_info.get('service') else None
            
            if service in self.vulnerability_checks:
                try:
                    vulns = self.vulnerability_checks[service](target, port)
                    vulnerabilities.extend(vulns)
                except Exception as e:
                    self.logger.debug(f"Error checking {service} vulnerabilities: {e}")
                    
        return vulnerabilities
        
    def _check_ssh_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for SSH vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check SSH version using custom packet
            syn_packet = IP(dst=target)/TCP(dport=port, flags='S')
            response = sr1(syn_packet, timeout=2, verbose=0)
            
            if response and response.haslayer(TCP):
                # Send SSH version probe
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(2)
                    s.connect((target, port))
                    banner = s.recv(1024)
                    
                    # Check for old SSH versions
                    if b'SSH-1' in banner:
                        vulnerabilities.append(Vulnerability(
                            name="SSH Version 1 Detected",
                            description="SSH version 1 protocol is cryptographically broken",
                            severity="HIGH",
                            port=port,
                            service="SSH",
                            recommendations=["Upgrade to SSH version 2", "Disable SSH version 1 support"]
                        ))
                    
                    # Check for weak ciphers
                    if b'3des' in banner.lower() or b'blowfish' in banner.lower():
                        vulnerabilities.append(Vulnerability(
                            name="Weak SSH Ciphers",
                            description="Server supports weak encryption ciphers",
                            severity="MEDIUM",
                            port=port,
                            service="SSH",
                            recommendations=["Disable weak ciphers", "Configure strong cipher suite"]
                        ))
                        
        except Exception as e:
            self.logger.debug(f"Error checking SSH vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _check_ftp_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for FTP vulnerabilities"""
        vulnerabilities = []
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((target, port))
                banner = s.recv(1024)
                
                # Check for anonymous FTP
                s.send(b"USER anonymous\r\n")
                response = s.recv(1024)
                if b"331" in response:  # Anonymous login possible
                    s.send(b"PASS anonymous@example.com\r\n")
                    response = s.recv(1024)
                    if b"230" in response:  # Anonymous login successful
                        vulnerabilities.append(Vulnerability(
                            name="Anonymous FTP Access",
                            description="Server allows anonymous FTP access",
                            severity="HIGH",
                            port=port,
                            service="FTP",
                            recommendations=["Disable anonymous FTP access", "Require authentication"]
                        ))
                        
                # Check for clear text FTP
                if not self._is_ftps_available(target, port):
                    vulnerabilities.append(Vulnerability(
                        name="Clear Text FTP",
                        description="FTP service does not support encryption",
                        severity="HIGH",
                        port=port,
                        service="FTP",
                        recommendations=["Enable FTPS (FTP over SSL/TLS)", "Configure strong encryption"]
                    ))
                    
        except Exception as e:
            self.logger.debug(f"Error checking FTP vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _is_ftps_available(self, target: str, port: int) -> bool:
        """Check if FTPS is available"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((target, port))
                s.send(b"AUTH TLS\r\n")
                response = s.recv(1024)
                return b"234" in response  # 234 indicates AUTH TLS is supported
        except Exception:
            return False
            
    def _check_http_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for HTTP vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for HTTP security headers
            url = f"http://{target}:{port}"
            response = requests.get(url, timeout=5, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (clickjacking protection)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header (MIME-sniffing protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection header (XSS protection)',
                'Content-Security-Policy': 'Missing Content-Security-Policy header'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append(Vulnerability(
                        name=f"Missing {header}",
                        description=description,
                        severity="MEDIUM",
                        port=port,
                        service="HTTP",
                        recommendations=[f"Add {header} header", "Configure secure HTTP headers"]
                    ))
                    
            # Check for HTTP methods
            methods_response = requests.options(url, timeout=5, verify=False)
            if 'Allow' in methods_response.headers:
                allowed_methods = methods_response.headers['Allow']
                dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
                
                for method in dangerous_methods:
                    if method in allowed_methods:
                        vulnerabilities.append(Vulnerability(
                            name=f"Dangerous HTTP Method: {method}",
                            description=f"Server allows {method} method which could be dangerous",
                            severity="MEDIUM",
                            port=port,
                            service="HTTP",
                            recommendations=[f"Disable {method} method", "Restrict HTTP methods"]
                        ))
                        
        except Exception as e:
            self.logger.debug(f"Error checking HTTP vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _check_https_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for HTTPS vulnerabilities"""
        vulnerabilities = []
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, port)) as sock:
                with context.wrap_socket(sock) as ssock:
                    cert = ssock.getpeercert(binary_form=True)
                    
                    # Check SSL/TLS version
                    version = ssock.version()
                    if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vulnerabilities.append(Vulnerability(
                            name=f"Weak {version} Protocol",
                            description=f"Server supports outdated {version} protocol",
                            severity="HIGH",
                            port=port,
                            service="HTTPS",
                            recommendations=[f"Disable {version}", "Enable only TLS 1.2 and above"]
                        ))
                        
                    # Check cipher suite
                    cipher = ssock.cipher()
                    if cipher and ('RC4' in cipher[0] or 'DES' in cipher[0]):
                        vulnerabilities.append(Vulnerability(
                            name="Weak Cipher Suite",
                            description=f"Server supports weak cipher: {cipher[0]}",
                            severity="HIGH",
                            port=port,
                            service="HTTPS",
                            recommendations=["Disable weak ciphers", "Configure strong cipher suite"]
                        ))
                        
        except Exception as e:
            self.logger.debug(f"Error checking HTTPS vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _check_smtp_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for SMTP vulnerabilities"""
        vulnerabilities = []
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((target, port))
                banner = s.recv(1024)
                
                # Check for open relay
                s.send(b"HELO test.com\r\n")
                s.recv(1024)
                s.send(b"MAIL FROM: test@test.com\r\n")
                response = s.recv(1024)
                
                if b"250" in response:  # MAIL FROM accepted
                    vulnerabilities.append(Vulnerability(
                        name="Potential SMTP Open Relay",
                        description="Server might be configured as an open relay",
                        severity="CRITICAL",
                        port=port,
                        service="SMTP",
                        recommendations=["Disable open relay", "Configure proper SMTP authentication"]
                    ))
                    
                # Check for STARTTLS
                s.send(b"STARTTLS\r\n")
                response = s.recv(1024)
                if b"220" not in response:
                    vulnerabilities.append(Vulnerability(
                        name="STARTTLS Not Supported",
                        description="SMTP server does not support STARTTLS encryption",
                        severity="HIGH",
                        port=port,
                        service="SMTP",
                        recommendations=["Enable STARTTLS", "Configure SSL/TLS encryption"]
                    ))
                    
        except Exception as e:
            self.logger.debug(f"Error checking SMTP vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _check_mysql_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for MySQL vulnerabilities"""
        vulnerabilities = []
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((target, port))
                banner = s.recv(1024)
                
                # Check for old MySQL versions
                if b"5.5" in banner or b"5.6" in banner:
                    vulnerabilities.append(Vulnerability(
                        name="Outdated MySQL Version",
                        description="Server is running an outdated version of MySQL",
                        severity="HIGH",
                        port=port,
                        service="MySQL",
                        recommendations=["Upgrade MySQL to latest version", "Apply security patches"]
                    ))
                    
        except Exception as e:
            self.logger.debug(f"Error checking MySQL vulnerabilities: {e}")
            
        return vulnerabilities
        
    def _check_postgresql_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for PostgreSQL vulnerabilities"""
        vulnerabilities = []
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect((target, port))
                
                # Try default credentials
                packet = b'\x00\x00\x00\x52'  # Startup message
                packet += b'\x00\x03\x00\x00'  # Protocol version
                packet += b'user\x00postgres\x00database\x00postgres\x00\x00'
                
                s.send(packet)
                response = s.recv(1024)
                
                if b'R' in response:  # Authentication request
                    vulnerabilities.append(Vulnerability(
                        name="Default PostgreSQL Credentials",
                        description="Server accepts default PostgreSQL credentials",
                        severity="CRITICAL",
                        port=port,
                        service="PostgreSQL",
                        recommendations=["Change default credentials", "Implement strong authentication"]
                    ))
                    
        except Exception as e:
            self.logger.debug(f"Error checking PostgreSQL vulnerabilities: {e}")
            
        return vulnerabilities
